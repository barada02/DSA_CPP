# DSA Fundamentals - Learning Plan
## Big O Notation, Time Complexity & Space Complexity

---

## üìö Learning Schedule

### **Session 1: Introduction to Algorithm Analysis**
- Why do we need algorithm analysis?
- What makes one algorithm better than another?
- Introduction to asymptotic notation
- The need for Big O notation

---

### **Session 2: Understanding Time Complexity**
- What is time complexity?
- How to measure algorithm efficiency
- Counting operations vs actual time
- Input size and its impact
- Basic examples with simple code

---

### **Session 3: Big O Notation - The Basics**
- Definition and mathematical meaning
- Big O, Big Omega (Œ©), Big Theta (Œò)
- Focus on Big O (upper bound)
- Rules for calculating Big O:
  - Drop constants
  - Drop lower order terms
  - Different inputs = different variables

---

### **Session 4: Common Time Complexities (Part 1)**
- **O(1) - Constant Time**
  - Examples and use cases
  - Array access, basic operations
- **O(log n) - Logarithmic Time**
  - Binary search example
  - Why dividing problems is efficient
- **O(n) - Linear Time**
  - Single loops
  - Linear search example

---

### **Session 5: Common Time Complexities (Part 2)**
- **O(n log n) - Linearithmic Time**
  - Efficient sorting algorithms (Merge Sort, Quick Sort)
- **O(n¬≤) - Quadratic Time**
  - Nested loops
  - Bubble sort, Selection sort
- **O(n¬≥) - Cubic Time**
  - Triple nested loops
- **O(2^n) - Exponential Time**
  - Recursive Fibonacci
  - Subset generation
- **O(n!) - Factorial Time**
  - Permutations
  - Traveling salesman brute force

---

### **Session 6: Space Complexity**
- What is space complexity?
- Memory usage analysis
- Auxiliary space vs total space
- Stack space in recursion
- In-place vs out-of-place algorithms
- Trade-offs between time and space

---

### **Session 7: Analyzing Code Patterns**
- Single loops analysis
- Nested loops analysis
- Sequential statements
- Conditional statements
- Multiple loops (non-nested)
- Practice problems

---

### **Session 8: Recursion and Time Complexity**
- Analyzing recursive functions
- Recurrence relations
- Master theorem (basic understanding)
- Recursion tree method
- Common recursive patterns

---

### **Session 9: Best, Average, and Worst Case**
- Understanding different cases
- When each case matters
- Amortized analysis (introduction)
- Examples: Quick Sort, Hash Tables

---

### **Session 10: Practice and Common Mistakes**
- Hidden complexities to watch for
- Common misconceptions
- Analyzing real DSA problems
- Tips for competitive programming
- Quick reference guide

---

## üéØ Learning Outcomes

By the end of this plan, you will be able to:
- ‚úÖ Understand and explain Big O notation
- ‚úÖ Calculate time complexity of any code
- ‚úÖ Calculate space complexity of algorithms
- ‚úÖ Compare different algorithms efficiently
- ‚úÖ Make informed decisions about algorithm selection
- ‚úÖ Optimize code based on complexity analysis

---

## üìù Files to be Created

Each session will have its own markdown file:
1. `01_IntroToAlgorithmAnalysis.md`
2. `02_TimeComplexity.md`
3. `03_BigONotation.md`
4. `04_CommonTimeComplexities_Part1.md`
5. `05_CommonTimeComplexities_Part2.md`
6. `06_SpaceComplexity.md`
7. `07_AnalyzingCodePatterns.md`
8. `08_RecursionComplexity.md`
9. `09_BestAverageWorstCase.md`
10. `10_PracticeAndTips.md`

---

## üöÄ Getting Started

We'll start with **Session 1: Introduction to Algorithm Analysis**. Each session will include:
- Theoretical concepts
- Visual examples
- Code examples in C++
- Practice problems
- Summary and key takeaways

**Ready to begin? Let's start with Session 1!**
